---
/**
 * Chart component for MDX blog posts
 * Uses Chart.js for rendering various chart types
 * Colors are imported from /src/styles/chart-colors.ts for consistency
 *
 * Usage in MDX:
 * <Chart
 *   type="bar"
 *   data={{
 *     labels: ['A', 'B', 'C'],
 *     datasets: [{ label: 'Values', data: [1, 2, 3] }]
 *   }}
 * />
 */
import { darkThemeColors, lightThemeColors } from '../styles/chart-colors';

interface Props {
	type: 'bar' | 'line' | 'pie' | 'doughnut' | 'radar' | 'scatter';
	data: {
		labels?: string[];
		datasets: Array<{
			label?: string;
			data: number[];
			backgroundColor?: string | string[];
			borderColor?: string | string[];
			borderWidth?: number;
			fill?: boolean;
		}>;
	};
	options?: Record<string, unknown>;
	width?: number;
	height?: number;
}

const { type, data, options = {}, width, height } = Astro.props;

// Generate unique ID for this chart instance
const chartId = `chart-${Math.random().toString(36).substr(2, 9)}`;

// Pass raw data and color config to client-side script for theme-aware rendering
const rawData = data;
const hasScales = type !== 'pie' && type !== 'doughnut' && type !== 'radar';
const userOptions = options;
const chartColorsDark = darkThemeColors;
const chartColorsLight = lightThemeColors;
---

<div class="chart-container">
	<canvas id={chartId} width={width} height={height}></canvas>
</div>

<script define:vars={{ chartId, type, rawData, hasScales, userOptions, chartColorsDark, chartColorsLight }}>
	// Detect current theme
	function isDarkMode() {
		const dataTheme = document.documentElement.getAttribute('data-theme');
		if (dataTheme === 'light') return false;
		if (dataTheme === 'dark') return true;
		// Fall back to system preference
		return !window.matchMedia('(prefers-color-scheme: light)').matches;
	}

	// Get theme-aware colors from centralized config
	function getColors(isDark) {
		return isDark ? chartColorsDark : chartColorsLight;
	}
	
	// Check if chart type needs per-segment colors (pie, doughnut)
	const needsSegmentColors = type === 'pie' || type === 'doughnut';

	let chartInstance = null;

	function createChart(Chart) {
		const ctx = document.getElementById(chartId);
		if (!ctx) return;

		// Destroy existing chart if any
		if (chartInstance) {
			chartInstance.destroy();
		}

		const isDark = isDarkMode();
		const { colors, borders, text, grid } = getColors(isDark);

		const processedData = {
			...rawData,
			datasets: rawData.datasets.map((dataset, index) => {
				// For pie/doughnut charts, apply array of colors to each segment
				if (needsSegmentColors && !dataset.backgroundColor) {
					const segmentCount = dataset.data.length;
					const segmentColors = [];
					const segmentBorders = [];
					for (let i = 0; i < segmentCount; i++) {
						segmentColors.push(colors[i % colors.length]);
						segmentBorders.push(borders[i % borders.length]);
					}
					return {
						...dataset,
						backgroundColor: segmentColors,
						borderColor: segmentBorders,
						borderWidth: dataset.borderWidth ?? 2,
					};
				}
				// For line/bar/other charts, use single color per dataset
				return {
					...dataset,
					backgroundColor: dataset.backgroundColor || colors[index % colors.length],
					borderColor: dataset.borderColor || borders[index % borders.length],
					borderWidth: dataset.borderWidth ?? 2,
				};
			}),
		};

		const chartOptions = {
			responsive: true,
			maintainAspectRatio: true,
			plugins: {
				legend: {
					labels: {
						color: text,
						font: {
							family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
						},
					},
				},
			},
			scales: hasScales ? {
				x: {
					ticks: {
						color: text,
						font: {
							family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
						},
					},
					grid: { color: grid },
				},
				y: {
					ticks: {
						color: text,
						font: {
							family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
						},
					},
					grid: { color: grid },
				},
			} : undefined,
			...userOptions,
		};

		chartInstance = new Chart(ctx, {
			type: type,
			data: processedData,
			options: chartOptions,
		});
	}

	// Dynamic import Chart.js only when needed
	import('https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js').then(() => {
		const Chart = window.Chart;

		// Create initial chart
		createChart(Chart);

		// Watch for theme changes and recreate chart
		const observer = new MutationObserver((mutations) => {
			for (const mutation of mutations) {
				if (mutation.attributeName === 'data-theme') {
					createChart(Chart);
					break;
				}
			}
		});

		observer.observe(document.documentElement, {
			attributes: true,
			attributeFilter: ['data-theme'],
		});
	});
</script>

<style>
	.chart-container {
		width: 100%;
		max-width: 600px;
		margin: 2em auto;
		padding: 1.5em;
		background: var(--bg-secondary);
		border-radius: 12px;
		border: 1px solid rgb(var(--border));
		box-shadow: var(--box-shadow);
		transition: background-color 0.3s ease, border-color 0.3s ease;
	}
</style>
