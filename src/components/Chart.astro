---
/**
 * Chart component for MDX blog posts
 * Uses Chart.js for rendering various chart types
 *
 * Usage in MDX:
 * <Chart
 *   type="bar"
 *   data={{
 *     labels: ['A', 'B', 'C'],
 *     datasets: [{ label: 'Values', data: [1, 2, 3] }]
 *   }}
 * />
 */
interface Props {
	type: 'bar' | 'line' | 'pie' | 'doughnut' | 'radar' | 'scatter';
	data: {
		labels?: string[];
		datasets: Array<{
			label?: string;
			data: number[];
			backgroundColor?: string | string[];
			borderColor?: string | string[];
			borderWidth?: number;
			fill?: boolean;
		}>;
	};
	options?: Record<string, unknown>;
	width?: number;
	height?: number;
}

const { type, data, options = {}, width, height } = Astro.props;

// Generate unique ID for this chart instance
const chartId = `chart-${Math.random().toString(36).substr(2, 9)}`;

// Pass raw data to client-side script for theme-aware rendering
const rawData = data;
const hasScales = type !== 'pie' && type !== 'doughnut' && type !== 'radar';
const userOptions = options;
---

<div class="chart-container">
	<canvas id={chartId} width={width} height={height}></canvas>
</div>

<script define:vars={{ chartId, type, rawData, hasScales, userOptions }}>
	// Detect current theme
	function isDarkMode() {
		const dataTheme = document.documentElement.getAttribute('data-theme');
		if (dataTheme === 'light') return false;
		if (dataTheme === 'dark') return true;
		// Fall back to system preference
		return !window.matchMedia('(prefers-color-scheme: light)').matches;
	}

	// Theme-aware colors - diverse palette with high contrast
	function getColors(isDark) {
		if (isDark) {
			// Vibrant, distinct colors on dark background
			return {
				colors: [
					'rgba(45, 212, 191, 0.9)',    // Teal (primary)
					'rgba(251, 146, 60, 0.9)',    // Orange
					'rgba(168, 85, 247, 0.9)',    // Purple
					'rgba(251, 191, 36, 0.9)',    // Amber/Yellow
					'rgba(236, 72, 153, 0.9)',    // Pink
					'rgba(34, 197, 94, 0.9)',     // Green
					'rgba(96, 165, 250, 0.9)',    // Blue
				],
				borders: [
					'rgb(45, 212, 191)',
					'rgb(251, 146, 60)',
					'rgb(168, 85, 247)',
					'rgb(251, 191, 36)',
					'rgb(236, 72, 153)',
					'rgb(34, 197, 94)',
					'rgb(96, 165, 250)',
				],
				text: 'rgb(244, 244, 245)',
				grid: 'rgba(63, 63, 70, 0.5)',
			};
		}
		// Vibrant, distinct colors on light background
		return {
			colors: [
				'rgba(13, 148, 136, 0.85)',    // Teal (primary)
				'rgba(234, 88, 12, 0.85)',     // Orange
				'rgba(147, 51, 234, 0.85)',    // Purple
				'rgba(202, 138, 4, 0.85)',     // Amber/Yellow
				'rgba(219, 39, 119, 0.85)',    // Pink
				'rgba(22, 163, 74, 0.85)',     // Green
				'rgba(37, 99, 235, 0.85)',     // Blue
			],
			borders: [
				'rgb(13, 148, 136)',
				'rgb(234, 88, 12)',
				'rgb(147, 51, 234)',
				'rgb(202, 138, 4)',
				'rgb(219, 39, 119)',
				'rgb(22, 163, 74)',
				'rgb(37, 99, 235)',
			],
			text: 'rgb(41, 37, 36)',
			grid: 'rgba(214, 211, 209, 0.7)',
		};
	}
	
	// Check if chart type needs per-segment colors (pie, doughnut)
	const needsSegmentColors = type === 'pie' || type === 'doughnut';

	let chartInstance = null;

	function createChart(Chart) {
		const ctx = document.getElementById(chartId);
		if (!ctx) return;

		// Destroy existing chart if any
		if (chartInstance) {
			chartInstance.destroy();
		}

		const isDark = isDarkMode();
		const { colors, borders, text, grid } = getColors(isDark);

		const processedData = {
			...rawData,
			datasets: rawData.datasets.map((dataset, index) => {
				// For pie/doughnut charts, apply array of colors to each segment
				if (needsSegmentColors && !dataset.backgroundColor) {
					const segmentCount = dataset.data.length;
					const segmentColors = [];
					const segmentBorders = [];
					for (let i = 0; i < segmentCount; i++) {
						segmentColors.push(colors[i % colors.length]);
						segmentBorders.push(borders[i % borders.length]);
					}
					return {
						...dataset,
						backgroundColor: segmentColors,
						borderColor: segmentBorders,
						borderWidth: dataset.borderWidth ?? 2,
					};
				}
				// For line/bar/other charts, use single color per dataset
				return {
					...dataset,
					backgroundColor: dataset.backgroundColor || colors[index % colors.length],
					borderColor: dataset.borderColor || borders[index % borders.length],
					borderWidth: dataset.borderWidth ?? 2,
				};
			}),
		};

		const chartOptions = {
			responsive: true,
			maintainAspectRatio: true,
			plugins: {
				legend: {
					labels: {
						color: text,
						font: {
							family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
						},
					},
				},
			},
			scales: hasScales ? {
				x: {
					ticks: {
						color: text,
						font: {
							family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
						},
					},
					grid: { color: grid },
				},
				y: {
					ticks: {
						color: text,
						font: {
							family: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
						},
					},
					grid: { color: grid },
				},
			} : undefined,
			...userOptions,
		};

		chartInstance = new Chart(ctx, {
			type: type,
			data: processedData,
			options: chartOptions,
		});
	}

	// Dynamic import Chart.js only when needed
	import('https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js').then(() => {
		const Chart = window.Chart;

		// Create initial chart
		createChart(Chart);

		// Watch for theme changes and recreate chart
		const observer = new MutationObserver((mutations) => {
			for (const mutation of mutations) {
				if (mutation.attributeName === 'data-theme') {
					createChart(Chart);
					break;
				}
			}
		});

		observer.observe(document.documentElement, {
			attributes: true,
			attributeFilter: ['data-theme'],
		});
	});
</script>

<style>
	.chart-container {
		width: 100%;
		max-width: 600px;
		margin: 2em auto;
		padding: 1.5em;
		background: var(--bg-secondary);
		border-radius: 12px;
		border: 1px solid rgb(var(--border));
		box-shadow: var(--box-shadow);
		transition: background-color 0.3s ease, border-color 0.3s ease;
	}
</style>
